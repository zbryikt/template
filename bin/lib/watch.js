// Generated by LiveScript 1.3.1
(function(){
  var fs, fsExtra, chokidar, path, debounce, PugTree, StylusTree, pug, stylus, lsc, aux, bundle, watch, process, this$ = this;
  fs = require('fs');
  fsExtra = require('fs-extra');
  chokidar = require('chokidar');
  path = require('path');
  debounce = require('debounce.js');
  PugTree = require('./tree/PugTree');
  StylusTree = require('./tree/StylusTree');
  pug = require('./build/pug');
  stylus = require('./build/stylus');
  lsc = require('./build/lsc');
  aux = require('./build/aux');
  bundle = require('./build/bundle');
  PugTree.setRoot('src/pug');
  StylusTree.setRoot('src/styl');
  watch = {
    ignores: [/^\..*\.swp$/],
    init: function(opt){
      var cfg, this$ = this;
      opt == null && (opt = {});
      cfg = {
        persistent: true,
        ignored: function(f){
          return this$.ignores.filter(function(it){
            return it.exec(f);
          }).length;
        }
      };
      if ((opt.watcher || (opt.watcher = {})).ignores) {
        this.ignores = (opt.watcher || (opt.watcher = {})).ignores;
      }
      this.ignores = this.ignores.map(function(it){
        return new RegExp(it);
      });
      this.watcher = chokidar.watch(['src', 'static'], cfg).on('add', function(it){
        return this$.update(it);
      }).on('change', function(it){
        return this$.update(it);
      }).on('unlink', function(it){
        return this$.unlink(it);
      });
      this.assets(opt.assets) || [];
      return console.log("[WATCHER] watching src for file change".cyan);
    },
    custom: function(arg$){
      var files, update, unlink, ignored, w;
      files = arg$.files, update = arg$.update, unlink = arg$.unlink, ignored = arg$.ignored;
      w = chokidar.watch(files, import$({
        persistent: true
      }, ignored
        ? {
          ignored: ignored
        }
        : {}));
      w.on('add', function(it){
        return update(it);
      });
      w.on('change', function(it){
        return update(it);
      });
      return w.on('unlink', function(it){
        return unlink(it);
      });
    },
    assets: function(assets){
      var modpath, desdir, add, remove;
      assets == null && (assets = []);
      modpath = 'node_modules';
      while (modpath.length < 50) {
        if (fs.existsSync(modpath)) {
          break;
        }
        modpath = path.join('..', modpath);
      }
      if (!fs.existsSync(modpath)) {
        return console.log("[ASSETS] node_modules dir not found.".red);
      }
      desdir = function(f){
        return path.join('static/assets', path.relative(modpath, path.dirname(f)), '..');
      };
      add = function(src){
        var des;
        des = path.join(desdir(src), path.basename(src));
        if (!aux.newer(src, [des])) {
          return;
        }
        fsExtra.ensureDirSync(desdir(src));
        fsExtra.copyFileSync(src, des);
        return console.log("[ASSETS] " + src + " -> " + des + " ");
      };
      remove = function(src){
        var des;
        des = path.join(desdir(src), path.basename(src));
        if (!fs.existsSync(des)) {
          return;
        }
        fs.unlinkSync(des);
        return console.log(("[ASSETS] " + src + " -> " + des + " deleted.").yellow);
      };
      return chokidar.watch(assets.map(function(it){
        return modpath + "/" + it + "/dist/";
      }), {
        persistent: true
      }).on('add', add).on('change', add).on('unlink', remove);
    },
    depend: {
      on: {},
      add: function(a, b){
        var ref$;
        if (!in$(a, (ref$ = this.on)[b] || (ref$[b] = []))) {
          return ((ref$ = this.on)[b] || (ref$[b] = [])).push(a);
        }
      }
    },
    handle: {},
    on: function(type, cb){
      var ref$;
      return ((ref$ = this.handle)[type] || (ref$[type] = [])).push(cb);
    },
    pending: {},
    unlink: function(f){
      var ret, k, ref$, key$;
      ret = /\.(.+)$/.exec(f);
      k = !ret
        ? ""
        : ret[1];
      ((ref$ = this.handle)[key$ = "unlink." + k] || (ref$[key$] = [])).map(function(cb){
        return cb([f]);
      });
      ((ref$ = this.handle)["unlink"] || (ref$["unlink"] = [])).map(function(cb){
        return cb([f]);
      });
      return this.update(f);
    },
    updateDebounced: debounce(100, function(){
      var k, ref$, list, cat, v, key$, this$ = this;
      ref$ = [
        (function(){
          var results$ = [];
          for (k in this.pending) {
            results$.push(k);
          }
          return results$;
        }.call(this)), {}, {}
      ], list = ref$[0], cat = ref$[1], this.pending = ref$[2];
      list.map(function(f){
        var ret;
        return [f, ret = /\.([^.]+)$/.exec(f)];
      }).map(function(it){
        var key$;
        return (cat[key$ = it[1] ? it[1][1] : ""] || (cat[key$] = [])).push(it[0]);
      });
      for (k in cat) {
        v = cat[k];
        ((ref$ = this.handle)[key$ = "build." + k] || (ref$[key$] = [])).map(fn$);
      }
      return ((ref$ = this.handle)["build"] || (ref$["build"] = [])).map(function(cb){
        return cb(list);
      });
      function fn$(cb){
        return cb(v);
      }
    }),
    update: function(f){
      var list, e, this$ = this;
      try {
        f = f.split(path.sep).join('/');
        list = Array.isArray(f)
          ? f
          : [f];
        list = (list.concat(list.map(function(it){
          return this$.depend.on[it];
        }).reduce(function(a, b){
          return a.concat(b);
        }, []))).filter(function(it){
          return it;
        });
        list.map(function(it){
          var ref$;
          return ((ref$ = this$.pending)[it] || (ref$[it] = {}))[f] = true;
        });
        return this.updateDebounced();
      } catch (e$) {
        e = e$;
        console.log("[WATCHER] Update failed with following information: ".red);
        return console.log(e);
      }
    }
  };
  process = function(parser, builder){
    return function(list){
      var files, i$, len$, n, k;
      files = {};
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
        n = list[i$];
        parser.parse(n).map(fn$);
        parser.affect(n).map(fn1$);
      }
      return builder.build((function(){
        var results$ = [];
        for (k in files) {
          results$.push(k);
        }
        return results$;
      }()), files);
      function fn$(f){
        return watch.depend.add(n, f);
      }
      function fn1$(it){
        return (files[it] || (files[it] = [])).push(n);
      }
    };
  };
  watch.on('build.pug', process(PugTree, pug));
  watch.on('build.styl', process(StylusTree, stylus));
  watch.on('build.ls', function(it){
    return lsc.build(it);
  });
  watch.on('unlink.pug', function(it){
    return pug.unlink(it);
  });
  watch.on('unlink.styl', function(it){
    return stylus.unlink(it);
  });
  watch.on('unlink.ls', function(it){
    return lsc.unlink(it);
  });
  watch.custom({
    files: ['static', 'bundle.json'],
    ignored: function(f){
      return watch.ignores.filter(function(it){
        return it.exec(f);
      }).length || /static\/(js|css)\/pack\//.exec(f);
    },
    update: function(it){
      return bundle.build([it]);
    },
    unlink: function(it){
      return bundle.unlink([it]);
    }
  });
  module.exports = watch;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
