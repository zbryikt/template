// Generated by LiveScript 1.6.0
var fs, fsExtra, chokidar, path, debounce, i18n, PugTree, StylusTree, pug, stylus, lsc, aux, bundle, watch, process;
fs = require('fs');
fsExtra = require('fs-extra');
chokidar = require('chokidar');
path = require('path');
debounce = require('@loadingio/debounce.js');
i18n = require('./i18n');
PugTree = require('./tree/PugTree');
StylusTree = require('./tree/StylusTree');
pug = require('./build/pug');
stylus = require('./build/stylus');
lsc = require('./build/lsc');
aux = require('./build/aux');
bundle = require('./build/bundle');
PugTree.setRoot('src/pug');
StylusTree.setRoot('src/styl');
watch = {
  ignores: [/^\..*\.swp$/],
  init: function(opt){
    var this$ = this;
    opt == null && (opt = {});
    return i18n(opt.i18n).then(function(i18n){
      var cfg;
      pug.opt({
        i18n: i18n
      });
      cfg = {
        persistent: true,
        ignored: function(f){
          return this$.ignores.filter(function(it){
            return it.exec(f);
          }).length;
        }
      };
      if ((opt.watcher || (opt.watcher = {})).ignores) {
        this$.ignores = (opt.watcher || (opt.watcher = {})).ignores;
      }
      this$.ignores = this$.ignores.map(function(it){
        return new RegExp(it);
      });
      this$.watcher = chokidar.watch(['src', 'static'], cfg).on('add', function(it){
        return this$.update(it);
      }).on('change', function(it){
        return this$.update(it);
      }).on('unlink', function(it){
        return this$.unlink(it);
      });
      this$.assets(opt.assets) || [];
      return console.log("[WATCHER] watching src for file change".cyan);
    });
  },
  custom: function(arg$){
    var files, update, unlink, ignored, w;
    files = arg$.files, update = arg$.update, unlink = arg$.unlink, ignored = arg$.ignored;
    w = chokidar.watch(files, import$({
      persistent: true
    }, ignored
      ? {
        ignored: ignored
      }
      : {}));
    w.on('add', function(it){
      return update(it);
    });
    w.on('change', function(it){
      return update(it);
    });
    return w.on('unlink', function(it){
      return unlink(it);
    });
  },
  assets: function(assets){
    var modpath, desdir, add, remove;
    assets == null && (assets = []);
    modpath = 'node_modules';
    while (modpath.length < 50) {
      if (fs.existsSync(modpath)) {
        break;
      }
      modpath = path.join('..', modpath);
    }
    if (!fs.existsSync(modpath)) {
      return console.log("[ASSETS] node_modules dir not found.".red);
    }
    desdir = function(f){
      return path.join('static/assets', path.relative(modpath, path.dirname(f)), '..');
    };
    add = function(src){
      var des;
      des = path.join(desdir(src), path.basename(src));
      if (!aux.newer(src, [des])) {
        return;
      }
      fsExtra.ensureDirSync(desdir(src));
      fsExtra.copyFileSync(src, des);
      return console.log("[ASSETS] " + src + " -> " + des + " ");
    };
    remove = function(src){
      var des;
      des = path.join(desdir(src), path.basename(src));
      if (!fs.existsSync(des)) {
        return;
      }
      fs.unlinkSync(des);
      return console.log(("[ASSETS] " + src + " -> " + des + " deleted.").yellow);
    };
    return chokidar.watch(assets.map(function(it){
      return modpath + "/" + it + "/dist/";
    }), {
      persistent: true
    }).on('add', add).on('change', add).on('unlink', remove);
  },
  depend: {
    on: {},
    add: function(a, b){
      var ref$;
      if (!in$(a, (ref$ = this.on)[b] || (ref$[b] = []))) {
        return ((ref$ = this.on)[b] || (ref$[b] = [])).push(a);
      }
    }
  },
  handle: {},
  on: function(type, cb){
    var ref$;
    return ((ref$ = this.handle)[type] || (ref$[type] = [])).push(cb);
  },
  pending: {},
  unlink: function(f){
    var ret, k, ref$, key$;
    ret = /\.(.+)$/.exec(f);
    k = !ret
      ? ""
      : ret[1];
    ((ref$ = this.handle)[key$ = "unlink." + k] || (ref$[key$] = [])).map(function(cb){
      return cb([{
        file: f
      }]);
    });
    ((ref$ = this.handle)["unlink"] || (ref$["unlink"] = [])).map(function(cb){
      return cb([{
        file: f
      }]);
    });
    return this.update(f);
  },
  updateDebounced: debounce(100, function(){
    var list, k, ref$, v, f, t, cat, i$, len$, item, ret, key$;
    list = [];
    for (k in ref$ = this.pending) {
      v = ref$[k];
      list.push({
        file: k,
        mtime: Math.max.apply(Math, (fn$()))
      });
    }
    ref$ = [{}, {}], this.pending = ref$[0], cat = ref$[1];
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      item = list[i$];
      ret = /\.([^.]+)$/.exec(item.file);
      (cat[key$ = ret ? ret[1] : ''] || (cat[key$] = [])).push(item);
    }
    for (k in cat) {
      v = cat[k];
      ((ref$ = this.handle)[key$ = "build." + k] || (ref$[key$] = [])).map(fn1$);
    }
    return ((ref$ = this.handle)["build"] || (ref$["build"] = [])).map(function(cb){
      return cb(list);
    });
    function fn$(){
      var ref$, results$ = [];
      for (f in ref$ = v) {
        t = ref$[f];
        results$.push(t);
      }
      return results$;
    }
    function fn1$(cb){
      return cb(v);
    }
  }),
  update: function(f){
    var list, e, this$ = this;
    try {
      f = f.split(path.sep).join('/');
      list = Array.isArray(f)
        ? f
        : [f];
      list = (list.concat(list.map(function(it){
        return this$.depend.on[it];
      }).reduce(function(a, b){
        return a.concat(b);
      }, []))).filter(function(it){
        return it;
      });
      list.map(function(it){
        var ref$;
        if (fs.existsSync(f)) {
          return ((ref$ = this$.pending)[it] || (ref$[it] = {}))[f] = fs.statSync(f).mtime;
        }
      });
      return this.updateDebounced();
    } catch (e$) {
      e = e$;
      console.log("[WATCHER] Update failed with following information: ".red);
      return console.log(e);
    }
  }
};
process = function(parser, builder){
  return function(list){
    var files, i$, len$, n, k, v;
    files = {};
    for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
      n = list[i$];
      parser.parse(n).map(fn$);
      parser.affect(n).map(fn1$);
    }
    list = [];
    for (k in files) {
      v = files[k];
      list.push({
        file: k,
        mtime: Math.max.apply(Math, v.map(fn2$))
      });
    }
    return builder.build(list, files);
    function fn$(f){
      return watch.depend.add(n.file, f);
    }
    function fn1$(it){
      return (files[it] || (files[it] = [])).push(n);
    }
    function fn2$(it){
      return it.mtime;
    }
  };
};
watch.on('build.pug', process(PugTree, pug));
watch.on('build.styl', process(StylusTree, stylus));
watch.on('build.ls', function(it){
  return lsc.build(it);
});
watch.on('unlink.pug', function(it){
  return pug.unlink(it);
});
watch.on('unlink.styl', function(it){
  return stylus.unlink(it);
});
watch.on('unlink.ls', function(it){
  return lsc.unlink(it);
});
watch.custom({
  files: ['static', 'bundle.json'],
  ignored: function(f){
    return watch.ignores.filter(function(it){
      return it.exec(f);
    }).length || /static\/(js|css)\/pack\//.exec(f);
  },
  update: function(it){
    return bundle.build([{
      file: it
    }]);
  },
  unlink: function(it){
    return bundle.unlink([{
      file: it
    }]);
  }
});
module.exports = watch;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}